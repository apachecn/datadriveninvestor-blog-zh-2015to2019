# ECDSA —加密签名的艺术

> 原文：<https://medium.datadriveninvestor.com/ecdsa-the-art-of-cryptographic-signatures-33373fbe0650?source=collection_archive---------13----------------------->

[![](img/26f4cbdd7af11bf2fd8afa11d1c8eace.png)](http://www.track.datadriveninvestor.com/1B9E)

## 本文旨在用一点数学知识介绍椭圆曲线数字签名算法。

![](img/5656c5ff51fcf8523532f4ab1ec87e3f.png)

Source: [https://www.google.com/search?q=cryptography&source=lnms&tbm=isch&sa=X&ved=0ahUKEwjPzYmU3LHgAhWcxMQBHbVBDnQQ_AUIDigB&biw=1366&bih=639#imgrc=HMwO0HJzy6-qwM](https://www.google.com/search?q=cryptography&source=lnms&tbm=isch&sa=X&ved=0ahUKEwjPzYmU3LHgAhWcxMQBHbVBDnQQ_AUIDigB&biw=1366&bih=639#imgrc=HMwO0HJzy6-qwM):

## 介绍

在我之前的一篇文章[“了解如何编写椭圆曲线加密算法”](https://blog.goodaudience.com/learn-how-to-code-elliptic-curve-cryptography-26ecc0940d1f)中，我试图根据椭圆曲线的数学原理来展示加密算法背后的机制。由于在椭圆曲线上取一点并将其与自身相加导致另一点也位于该曲线上，因此可以将私钥定义为大数 *d* 并将公钥 *P* 定义为数 *d* 与曲线上的选定点 *G* 的标量积:

> ⋅ G

因此，公钥和私钥之间有着深刻的联系——它们属于同一个部分。这可以用来发送带有签名的消息，签名只是证明消息的发送者确实是创建它的人。接收方无需知道发送方的私钥就可以验证签名本身。以这种方式工作的密码系统通常被称为非对称系统。在这篇文章中，我想更深入一点，描述如何创建和验证签名。

## 创建签名

基于椭圆曲线的数学创建数字签名被称为*椭圆曲线数字签名算法*，简称 ECDSA。让我们来看看这个算法的各个步骤。

假设网络中有两个参与者，我们称他们为 Alice 和 Bob。实际上，这两个名字似乎总是在密码系统的实际解释中使用。爱丽丝的公钥是 Pₐ，她的私钥是 dₐ.签名和验证过程不需要 Bob 的公钥和私钥。现在，Alice 想给 Bob 发送一条消息 *M* ，并且还想给这条消息提供一个签名。在应用*签名算法*之前，第一步是对消息进行哈希运算，并截断哈希的位长，使其符合所选椭圆曲线的属性。关于创建散列，我想向你推荐我以前的一篇文章[“构建一个简单的区块链”](https://medium.com/wieblebub/build-a-simple-blockchain-fe7ee48090d9)。在那里，我解释了加密散列函数是如何工作的，以及这种散列有什么属性。消息 *M* 的哈希如下:

> z =散列值(M)

现在我们已经有了散列值 *z* ，我们可以看看爱丽丝的签名算法将运行的步骤:

1.  从数字 *0，…，n-1* 的集合中选择一个大整数 *k* 。要理解算法，没必要去理解，在什么条件下选择数字 *n* 。连同用于获取公钥的点 *G* 一起，曲线上的另一个点 *E* 正在被计算:
    ***E= kG***
2.  计算出的点 h 有一个 x 坐标和一个 y 坐标，E= (xₑ ,yₑ).使用该点的 x 坐标，签名的第一部分将是:
    ***r =xₑmod n*** 缩写 mod 表示应用了模运算。放心吧！一点也不复杂。它只是意味着除了休息。如果你取一个数模另一个数，例如 7 mod 4，结果将是除法的余数。7 除以 4 的余数是 3，所以
    7 mod 4 = 3。
3.  如果 *r* 的结果等于零，则算法返回到步骤 1，并以新的数字 *k* 重新开始。
4.  现在将计算签名的第二部分。因此，ECDSA 需要 Alice 打算发送的消息的 Hash *z* ，她的私钥和最近计算的签名的第一部分 *r* 。签名的第二部分 *s* 具有以下形式:
    ***s =k⁻⋅(z+r⋅dₐ)mod n***
5.  如果 *s* 等于零，算法必须跳回第一步，重新开始。

经历这些步骤，最终会给你一对数字 ***(r，s)——***这就是你想要的签名。现在我们知道了签名是如何创建的，下一个感兴趣的部分将是，消息的接收者，即 Bob，如何验证它。

## 验证签名

艾丽丝发出了她的信息，鲍勃收到了，并附上了签名。现在他想知道他收到的信息是否真的来自爱丽丝。他得到的所有信息只是签名(r，s)本身、消息和爱丽丝的公钥 Pₐ.必须找到一种方法，他可以仅使用这些信息来验证签名。为此，鲍勃的验证算法需要计算点 *E* ，并且必须证明 xₑ满足以下要求:

***xₑ mod n = r***

关于 E 点，这个等式成立:

***E = k ⋅ G***

一个问题是，鲍勃不知道 k 是什么。但是有一个办法！让我们来看看签名算法第四步中的等式:

***s =k⁻⋅(z+r⋅dₐ)mod n*t58】**

我们可以用这种方式重新表达，这样我们就得到数字 k 的表达式:

***k =s⁻⋅(z+r⋅dₐ)modn***

对于 *k* 的这个表达式，我们可以重写计算点 *E* 的等式:

***e =*****t13】k⋅g =s⁻⋅(z+r⋅dₐ)⋅g mod n**

现在我们要做一点数学。我们先把括号相乘:

**t17】e =(s⁻⋅z⋅g)mod n+(s⁻⋅r⋅dₐ⋅g)mod nt19】**

记住本文介绍中给出的公钥的定义

***Pₐ = dₐ ⋅克***

我们可以用 Alice 的公钥代替私钥乘以点 *G* 。因此，现在可以仅使用消息的散列值 z、Alice 的公钥和签名的信息来计算点 E:

**t31】e =(s⁻⋅z⋅g)mod n+(s⁻⋅r⋅pₐ)mod nt33】**

既然我们已经得到了一种验证签名的方法，现在是总结验证算法的单个步骤的时候了:

1.  取签名(r，s)并计算乘法逆 s⁻。使用消息的截断散列 *z* ，计算数量
    ***A₁ = s⁻ ⋅ z***
2.  计算数量 ***A₂ = s⁻ ⋅ r*** 。
3.  评估点 ***E = A₁ ⋅ G + A₂ ⋅ Pₐ***
4.  取点 *E* 的 x 坐标 xₑ，检查以下条件是否成立:
    ***xₑmod n = r*** 如果该条件成立，则签名正确！

## 结束了

理解椭圆曲线签名算法的工作原理可能需要一点数学知识，但是我希望您仍然能够对底层机制有一点了解。如果你喜欢我的文章，请留下一些掌声。:)也可以随意评论。感谢阅读！